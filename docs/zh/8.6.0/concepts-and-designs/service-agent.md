# 服务自动打点代理

服务自动打点代理(Service Auto Instrument Agent) 是前述基于语言的原生代理中的一部分，这种代理需要依靠某些语言特性实现，通常是那些基于虚拟机的语言。


## 自动打点(Auto Instrument) 是什么意思?

许多用户都是在听说 “无需改动任何一行代码“ 时了解到这类代理的，
SkyWalking 也曾经把这种说法放在 README 页面，但实际上这种说法并不完全准确。
对于终端用户来说，这是对的，大部分情况下他们的确不需要修改代码。
然而，要知道代码实际上还是被代理所修改了，这种做法通常被称为 “运行时代码操作(runtime code manipulation)”。
其底层原理是自动打点代理利用了虚拟机提供的用于修改代码的接口来动态加入打点的代码，
如通过 `javaagent premain` 来修改 Java 类。

尽管我们提到了大部分自动打点代理是基于虚拟机的，但你其实也可以构建出针对编译期而非运行时的工具。

## 有什么限制?

自动打点大有裨益，你可以在编译时实现自动打点而不需要依赖虚拟机特性，但这也带来了一些限制：

- **进程内传播在多数情况下成为可能**. 许多高级编程语言(例如 Java，.NET) 常被用于构建业务系统。
通常来说单个请求的业务代码都在单一线程内执行，为确保上下文的安全性，传播是基于线程 ID 的。

- **仅对某些框架和库奏效**. 由于是代理负责在运行时修改代码，这意味着代理插件开发者事先就要知道
所要修改的代码是怎么样的。 因此，这类探针通常会维护着一个支持的框架/库列表。
以 Java 为例，请见 [SkyWalking Java 代理支持列表](../setup/service-agent/java-agent/Supported-list.md)。

- **跨线程操作并非总被支持**. 如上关于进程内传播的论述，单个请求的代码（尤其是业务逻辑）大都运行在一条线程之内。
然而在其他一些场景下，它们也会跨线程运行，例如分配任务到其他线程，任务池，或批处理。
一些语言甚至还提供了协程或类似于 `Goroutine` 的概念，其使得开发者可以低开销地来执行异步处理，
在这些场景下，自动打点也许会面临一些问题。

总而言之，自动打点并不神秘。简单来说就是开发者替你写了一个激活脚本(activation script) 来让打点操作自动完成，仅此而已。

## 下回分解

如果你想了解 SkyWalking 中的手动打点库，请参考 [手动打点 SDK](manual-sdk.md) 一节.

